\pdfbookmark[0]{Abstract}{abstract.1}
%\phantomsection
%\addcontentsline{toc}{chapter}{Abstract}
%%% The following was not used (i.e. the creation of an unnumbered chapter for the abstract was abandoned) 
%%%\begingroup
%%%\setlength\beforechapskip{48pt} % for some reason there was a slight difference in the position of the numbered and unnumbered chapter headers 
%%%\chapter*{\centering Abstrakt}
%%%\endgroup
%%%\label{sec:abstrakt}
%%%Lorem ipsum dolor sit amet eleifend et, congue arcu. Morbi tellus sit amet, massa. Vivamus est id risus. Sed sit amet, libero. Aenean ac ipsum. Mauris vel lectus. 
%%%
%%%Nam id nulla a adipiscing tortor, dictum ut, lobortis urna. Donec non dui. Cras tempus orci ipsum, molestie quis, lacinia varius nunc, rhoncus purus, consectetuer congue risus. 
%\mbox{}\vspace{2cm} % can be shifted depending on the length of the abstract 
\begin{abstract}
Ever increasing demand for computing power makes parallel programming
an invaluable tool for every software engineer. To fully reap the rewards of this paradigm, programmers need to make proper decisions at every step of software design. This thesis aims to alleviate this process with data driven recommendations for developers working on the .NET platform.
\\ \\ 
To arrive at the set of guidelines multiple versions of algorithms and software were implemented. .NET's Task Parallel Library, 
PLINQ, MapReduce and Fork/Join patterns and load balancing partitioners were used in the process. Each of the implementations was subjected to exhaustive tests using BenchmarkDotNet benchmarking library,
\\ \\ 
The results showed that theoretically sound parallel algorithm implemented poorly may even be slower than the unchanged sequential versions. Using functional programming concepts helped creating maintainable and readable solutions, decreasing the change of errors during implementation. Memory thread overhead did not show to be a major issue. Benchmarking at all stages of development proved to be imperative when programming for performance. 
\end{abstract}
\mykeywords{.NET, Task Parallel Library, parallelism, multithreading, benchmarking}
% It would be good to copy the keywords to the metadata of the pdf document (in the file Thesis.tex)
% Unfortunately, the implemented macro does not do it automatically, so the manual copy remains. 

{
\selectlanguage{polish}
\begin{abstract}
Wci¹¿ rosn¹cy popyt na moc obliczeniow¹ sprawia, ¿e programowanie równoleg³e to nieocenione narzêdzie dla ka¿dego in¿yniera oprogramowania. By w~pe³ni czerpaæ z zysków oferowanych przez ten paradygmat, programiœci musz¹ podejmowaæ odpowiednia decyzje na ka¿dym etapie projektowania aplikacji. Ta praca ma na celu u³atwienie tego procesu dla in¿ynierów pracuj¹cych na platformie .NET poprzez przedstawienie rekomendacji opartych na danych.
\\ \\ 
Algorytmy oraz oprogramowanie zosta³o wielokrotnie zaimplementowane na ró¿ne sposoby jako baza dla zestawu zaleceñ. Wykorzystano przy tym Task Parallel Library, PLINQ, wzorce MapReduce oraz Fork/Join i równowa¿enie obci¹¿enia danych. Ka¿da z implementacji zosta³a poddana wyczerpuj¹cy testom przy u¿yciu biblioteki BenchmarkDotNet.
\\ \\ 
Wyniki pokaza³y, ¿e teoretycznie poprawne równoleg³e algorytmy zaimplementowane w w¹tpliwy sposób mog¹ byæ wolniejsze ni¿ niezmienione wersje sekwencyjne. U¿ycie pojêc pochodz¹cych z programowania funkcyjnego pozwoli³o na opracowanie czytelnych i utrzymywalnych rozwi¹zañ, zmniejszaj¹cych ryzyko pope³nienia b³edu przy implementacji. Koszty zwi¹zane z zarz¹dzniem w¹tkami by³y znikome. Analiza porównawcza okaza³a siê byæ konieczna jako integralna czêœæ ka¿dego etapu projektowania rozwi¹zañ optymalnych wydajnoœciowo.

\end{abstract}
\mykeywords{.NET, Task Parallel Library, programowanie równoleg³e, wielow¹tkowoœæ, analiza porównawcza}\\ 
}
